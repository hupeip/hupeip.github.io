<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Web前端">
<meta property="og:url" content="https://hupeip.github.io/index.html">
<meta property="og:site_name" content="Web前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Web前端">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hupeip.github.io/"/>





  <title>Web前端</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Web前端</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端，技术，生活的艺术</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Kategorien
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/11/30/Vue中computed计算属性原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/30/Vue中computed计算属性原理/" itemprop="url">Vue中computed计算属性原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-30T21:31:06+08:00">
                2018-11-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/11/30/Vue中computed计算属性原理/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/11/30/Vue中computed计算属性原理/" class="cy_cmt_count" data-xid="2018/11/30/Vue中computed计算属性原理/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Computed 计算属性是 Vue 中常用的一个功能，但你理解它是怎么工作的吗？</p>
<p>官网的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // a computed getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` points to the vm instance</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="Situation"><a href="#Situation" class="headerlink" title="Situation"></a>Situation</h3><p>Vue 里的 Computed 属性非常频繁的被使用到，但并不是很清楚它的实现原理。比如：计算属性如何与属性建立依赖关系？属性发生变化又如何通知到计算属性重新计算？  </p>
<p>关于如何建立依赖关系，我的第一个想到的就是语法解析，但这样太浪费性能，因此排除，第二个想到的就是利用 JavaScript 单线程的原理和 Vue 的 Getter 设计，通过一个简单的发布订阅，就可以在一次计算属性求值的过程中收集到相关依赖。   </p>
<p>因此接下来的任务就是从 Vue 源码一步步分析 Computed 的实现原理。  </p>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>分析依赖收集实现原理，分析动态计算实现原理。  </p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><h4 id="data-属性初始化-getter-setter"><a href="#data-属性初始化-getter-setter" class="headerlink" title="data 属性初始化 getter setter"></a>data 属性初始化 getter setter</h4><p>(Obeject.defineProperty是Object的一个方法，第一个参数是对象名称，第二个参数是要设置的属性名，第三个参数是一个对象，它可以设置这个属性是否可修改、可写等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">        const value = getter ? getter.call(obj) : val</span><br><span class="line">        // 判断是否处于依赖收集状态</span><br><span class="line">        if (Dep.target) &#123;</span><br><span class="line">        // 建立依赖关系</span><br><span class="line">        dep.depend()</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">        return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 依赖发生变化，通知到计算属性重新计算</span><br><span class="line">        dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="computed-计算属性初始化"><a href="#computed-计算属性初始化" class="headerlink" title="computed 计算属性初始化"></a>computed 计算属性初始化</h4><pre><code>// 初始化计算属性
function initComputed (vm: Component, computed: Object) {
    ...
    // 遍历 computed 计算属性
    for (const key in computed) {
        ...
        // 创建 Watcher 实例
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions)

        // 创建属性 vm.reversedMessage，并将提供的函数将用作属性 vm.reversedMessage 的 getter，
        // 最终 computed 与 data 会一起混合到 vm 下，所以当 computed 与 data 存在重名属性时会抛出警告
        defineComputed(vm, key, userDef)
        ...
    }
}

export function defineComputed (target: any, key: string, userDef: Object | Function) {
    ...
    // 创建 get set 方法
    sharedPropertyDefinition.get = createComputedGetter(key)
    sharedPropertyDefinition.set = noop
    ...
    // 创建属性 vm.reversedMessage，并初始化 getter setter
    Object.defineProperty(target, key, sharedPropertyDefinition)
    }

    function createComputedGetter (key) {
    return function computedGetter () {
        const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]
        if (watcher) {
        if (watcher.dirty) {
            // watcher 暴露 evaluate 方法用于取值操作
            watcher.evaluate()
        }
        // 同第1步，判断是否处于依赖收集状态
        if (Dep.target) {
            watcher.depend()
        }
        return watcher.value
        }
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/10/10/nodejs学习笔记（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/10/nodejs学习笔记（一）/" itemprop="url">nodejs 模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-10T23:35:56+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/10/10/nodejs学习笔记（一）/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/10/10/nodejs学习笔记（一）/" class="cy_cmt_count" data-xid="2018/10/10/nodejs学习笔记（一）/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对nodeJS早有耳闻，但是一直迟迟没有对它下手，虽然在项目中有用过nodejs，但也没有系统的学习过，这次我们就来探究一下。</p>
<h3 id="node-js是什么东西"><a href="#node-js是什么东西" class="headerlink" title="node.js是什么东西?"></a>node.js是什么东西?</h3><ul>
<li>nodejs是以chrome v8为运行环境的一个平台,它不是一门语言,而是一个平台</li>
<li>nodejs致力于是构建速度快,稳定的网络程序更简单</li>
<li>它具有事件驱动和非阻塞I/O的特色,使之轻量级并且高效率 </li>
<li>它非常适合在分布式设备运行数据密集型实时应用程序</li>
</ul>
<p>讲到这里,我们大概的明白了nodejs是一个平台,是一个环境,它是由chrome v8引擎来做底层支持,使用JavaScript来做语言支持,大概意思就是我们之前使用JavaScript运行在浏览器端去处理dom,bom操作等等,现在JavaScript运行在服务器去处理数据的增删改查,接受请求,发送数据,查找修改文件。<br>JavaScript以前是在浏览器端跑,现在有了nodejs就可以在后端跑,就像汽车原本只能在公路上跑,现在你给他装了nodejs,它现在可以在水里跑了一样.</p>
<h3 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h3><p>1.官网下载<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS安装包</a>。<br>2.在下载完安装包后，按照默认程序安装。<br>3.检验是否安装成功，打开命令提示符，输入node – v，如果正常就会出现版本号的输出。<br>在安装nodejs时，也一并安装了npm, 命令行输入npm -v 查看npm版本。<br>这样环境就已经搭建完成，很简单。<br>接下来我们就来了解一下nodejs的基础知识</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Node应用是由模块组成的，Node遵循了CommonJS的模块规范，来隔离每个模块的作用域，使每个模块在它自身的命名空间中执行<br>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。<br>创建一个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//hello.js </span><br><span class="line">function Hello() &#123; </span><br><span class="line">    var name; </span><br><span class="line">    this.setName = function(thyName) &#123; </span><br><span class="line">        name = thyName; </span><br><span class="line">    &#125;; </span><br><span class="line">    this.sayHello = function() &#123; </span><br><span class="line">        console.log(&apos;Hello &apos; + name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line">module.exports = Hello; // 暴露出去，其他文件可以引入这个模块</span><br></pre></td></tr></table></figure></p>
<p>引入这个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//main.js </span><br><span class="line">var Hello = require(&apos;./hello&apos;);  // 引入hello文件</span><br><span class="line">hello = new Hello(); </span><br><span class="line">hello.setName(&apos;BYVoid&apos;); </span><br><span class="line">hello.sayHello();</span><br></pre></td></tr></table></figure></p>
<p>这是我们自己写的一个简单的模块，nodejs还提供了一些原生的模块，如http、fs、path等，都是可以直接引入使用的，这些我们后面再介绍。</p>
<h3 id="fs-处理文件的模块"><a href="#fs-处理文件的模块" class="headerlink" title="fs 处理文件的模块"></a>fs 处理文件的模块</h3><p>fs模块用于对系统文件及目录进行读写操作  </p>
<h4 id="理解同步和异步方法"><a href="#理解同步和异步方法" class="headerlink" title="理解同步和异步方法"></a>理解同步和异步方法</h4><p>模块中所有方法都有同步和异步两种形式（异步方式主要是使用回调函数) , 例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。<br>建议使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞</p>
<h4 id="readFile读取文件"><a href="#readFile读取文件" class="headerlink" title="readFile读取文件"></a>readFile读取文件</h4><p>fs.readFile(filename,[option],callback) 方法读取文件。 </p>
<p>例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;); // 引入fs模块</span><br><span class="line">// 异步</span><br><span class="line">fs.readFile(&apos;./1.txt&apos;, &apos;utf-8&apos;, function(err, data) &#123;</span><br><span class="line">    // 读取文件失败/错误</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">    // 读取文件成功</span><br><span class="line">    console.log(&apos;utf-8: &apos;, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 同步</span><br><span class="line">fs.readFileSync(&apos;./1.txt&apos;,&apos;utf-8&apos;)。</span><br></pre></td></tr></table></figure>
<h4 id="WriteFile写入文件"><a href="#WriteFile写入文件" class="headerlink" title="WriteFile写入文件"></a>WriteFile写入文件</h4><p>使用fs.writeFile(filename,data,[options],callback)写入内容到文件。  </p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;); // 引入fs模块</span><br><span class="line"></span><br><span class="line">// 写入文件内容（如果文件不存在会创建一个文件）</span><br><span class="line">//配置参数flag：</span><br><span class="line">/*</span><br><span class="line">* a ：追加</span><br><span class="line">* w ：写入</span><br><span class="line">* r ：读取</span><br><span class="line">* */</span><br><span class="line">fs.writeFile(&apos;./2.txt&apos;, &apos;hello&apos;, &#123; &apos;flag&apos;: &apos;a&apos; &#125;, function(err) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;成功&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 同步只是去掉回调函数</span><br></pre></td></tr></table></figure>
<h4 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 异步</span><br><span class="line">fs.unlink(&quot;2.txt&quot;,function (err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        return console.log(err)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        console.log(&quot;删除成功&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 同步只是去掉回调函数</span><br></pre></td></tr></table></figure>
<h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建 new 目录</span><br><span class="line">fs.mkdir(&apos;./new&apos;, function(err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        return console.log(err)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        console.log(&apos;success.&apos;);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 删除目录 ，只能删除空文件夹</span><br><span class="line">fs.rmdir(&quot;./new&quot;,function (err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        return console.log(err)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        console.log(&quot;删除成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>对于NodeJS来说比较重要的一块就是http模块，我们使用http模块可以自己搭建服务器，从而监听客户端的一些请求，和客户端合作接受请求并且返回数据。  </p>
<h4 id="http模块搭建简易服务器"><a href="#http模块搭建简易服务器" class="headerlink" title="http模块搭建简易服务器"></a>http模块搭建简易服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">http.createServer(function(req,res)&#123;</span><br><span class="line">    res.writeHead(200,&#123;</span><br><span class="line">        &quot;content-type&quot;:&quot;text/plain&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(&quot;hello nodejs&quot;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;).listen(3000);</span><br><span class="line"></span><br><span class="line">console.log(&apos;Server is running at http://127.0.0.1:3000/&apos;);</span><br></pre></td></tr></table></figure>
<p>这就是一个简易的服务器，当然我们的业务场景肯定不会这么简单，下面继续扩展一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">// 引入一些需要用到的模块</span><br><span class="line">var</span><br><span class="line">    fs = require(&apos;fs&apos;),</span><br><span class="line">    url = require(&apos;url&apos;),</span><br><span class="line">    path = require(&apos;path&apos;),</span><br><span class="line">    http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">// 从命令行参数获取root目录，默认是当前目录:</span><br><span class="line">var root = path.resolve(process.argv[2] || &apos;.&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;Static root dir: &apos; + root);</span><br><span class="line"></span><br><span class="line">// 创建服务器:</span><br><span class="line">var server = http.createServer(function (request, response) &#123;</span><br><span class="line">    // 获得URL的path，类似 &apos;/css/test.css&apos;:</span><br><span class="line">    var pathname = url.parse(request.url).pathname;</span><br><span class="line">    // 获得对应的本地文件路径，类似 &apos;/src/www/css/test.css&apos;:</span><br><span class="line">    var filepath = path.join(root, pathname);</span><br><span class="line">    // 获取文件状态:</span><br><span class="line">    fs.stat(filepath, function (err, stats) &#123;</span><br><span class="line">        if (!err &amp;&amp; stats.isFile()) &#123;</span><br><span class="line">            // 没有出错并且文件存在:</span><br><span class="line">            console.log(&apos;200 &apos; + request.url);</span><br><span class="line">            // 发送200响应:</span><br><span class="line">            response.writeHead(200);</span><br><span class="line">            // 将文件流导向response:</span><br><span class="line">            fs.createReadStream(filepath).pipe(response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 出错了或者文件不存在:</span><br><span class="line">            console.log(&apos;404 &apos; + request.url);</span><br><span class="line">            // 发送404响应:</span><br><span class="line">            response.writeHead(404);</span><br><span class="line">            response.end(&apos;404 Not Found&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000);</span><br><span class="line"></span><br><span class="line">console.log(&apos;Server is running at http://127.0.0.1:3000/&apos;);</span><br></pre></td></tr></table></figure>
<p>pipe()管道方法自动读取文件内容并输出到HTTP响应</p>
<p>之后再来介绍里面具体的方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/10/08/axios拦截器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/08/axios拦截器/" itemprop="url">axios拦截器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-08T22:16:25+08:00">
                2018-10-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/10/08/axios拦截器/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/10/08/axios拦截器/" class="cy_cmt_count" data-xid="2018/10/08/axios拦截器/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>页面发送http请求，很多情况我们要对请求和其响应进行特定的处理；如果请求数非常多，单独对每一个请求进行处理会变得非常麻烦，程序的优雅性也会大打折扣。好在强大的axios为开发者提供了这样一个API：拦截器。拦截器分为 请求（request）拦截器和 响应（response）拦截器。</p>
<h3 id="axios拦截器简单介绍"><a href="#axios拦截器简单介绍" class="headerlink" title="axios拦截器简单介绍"></a>axios拦截器简单介绍</h3><h4 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">    // 在发起请求请做一些业务处理</span><br><span class="line">    return config;</span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">    // 对请求失败做处理</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">    // 对响应数据做处理</span><br><span class="line">    return response;</span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">    // 对响应错误做处理</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="vue添加axios拦截器"><a href="#vue添加axios拦截器" class="headerlink" title="vue添加axios拦截器"></a>vue添加axios拦截器</h3><h4 id="安装-axios"><a href="#安装-axios" class="headerlink" title="安装 axios"></a>安装 axios</h4><p>npm install axios –save-dev</p>
<h4 id="新建文件-axios-js"><a href="#新建文件-axios-js" class="headerlink" title="新建文件 axios.js"></a>新建文件 axios.js</h4><p>开始统一封装axios， 首先引入axios、qs依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">import qs from &quot;qs&quot;;</span><br></pre></td></tr></table></figure>
<p>然后创建一个axios实例，这个process.env.BASE_URL在config/dev.evn.js、prod.evn.js里面进行配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/****** 创建axios实例 ******/</span><br><span class="line">const service = axios.create(&#123;</span><br><span class="line">    baseURL: process.env.BASE_URL,  // api的base_url</span><br><span class="line">    timeout: 5000  // 请求超时时间</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="使用request拦截器对axios请求配置做统一处理"><a href="#使用request拦截器对axios请求配置做统一处理" class="headerlink" title="使用request拦截器对axios请求配置做统一处理"></a>使用request拦截器对axios请求配置做统一处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">service.interceptors.request.use(config =&gt; &#123;    </span><br><span class="line">    app.$vux.loading.show(&#123;        </span><br><span class="line">        text: &apos;数据加载中……&apos;    </span><br><span class="line">    &#125;);     </span><br><span class="line">    config.method === &apos;post&apos;        </span><br><span class="line">        ? config.data = qs.stringify(&#123;...config.data&#125;)        </span><br><span class="line">        : config.params = &#123;...config.params&#125;;    </span><br><span class="line">    config.headers[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;     </span><br><span class="line">    return config;</span><br><span class="line">    &#125;, error =&gt; &#123;  //请求错误处理   </span><br><span class="line">        app.$vux.toast.show(&#123;        </span><br><span class="line">            type: &apos;warn&apos;,        </span><br><span class="line">            text: error   </span><br><span class="line">        &#125;);    </span><br><span class="line">        Promise.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="对response做统一处理"><a href="#对response做统一处理" class="headerlink" title="对response做统一处理"></a>对response做统一处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">service.interceptors.response.use(    </span><br><span class="line">    response =&gt; &#123;  //成功请求到数据        </span><br><span class="line">        app.$vux.loading.hide();        </span><br><span class="line">        //这里根据后端提供的数据进行对应的处理        </span><br><span class="line">        if (response.data.result === &apos;TRUE&apos;) &#123;            </span><br><span class="line">            return response.data;        </span><br><span class="line">        &#125; else &#123;            </span><br><span class="line">            app.$vux.toast.show(&#123;  </span><br><span class="line">                //常规错误处理                </span><br><span class="line">                type: &apos;warn&apos;,                </span><br><span class="line">                text: response.data.data.msg            </span><br><span class="line">            &#125;);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    error =&gt; &#123;  //响应错误处理console.log(&apos;error&apos;);        </span><br><span class="line">        console.log(error);        </span><br><span class="line">        console.log(JSON.stringify(error));         </span><br><span class="line">        let text = JSON.parse(JSON.stringify(error)).response.status === 404            </span><br><span class="line">            ? &apos;404&apos;            </span><br><span class="line">            : &apos;网络异常，请重试&apos;;        </span><br><span class="line">        app.$vux.toast.show(&#123;            </span><br><span class="line">            type: &apos;warn&apos;,            </span><br><span class="line">            text: text        </span><br><span class="line">        &#125;);         </span><br><span class="line">        return Promise.reject(error)   </span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="将axios实例暴露出去"><a href="#将axios实例暴露出去" class="headerlink" title="将axios实例暴露出去"></a>将axios实例暴露出去</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default service;</span><br></pre></td></tr></table></figure>
<p>这样一个简单的拦截器就完成了</p>
<h4 id="在main-js中进行引用，并配置一个别名（-ajax）来进行调用"><a href="#在main-js中进行引用，并配置一个别名（-ajax）来进行调用" class="headerlink" title="在main.js中进行引用，并配置一个别名（$ajax）来进行调用"></a>在main.js中进行引用，并配置一个别名（$ajax）来进行调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import &apos;../axios.js&apos;    //axios.js的路径</span><br><span class="line"></span><br><span class="line">Vue.prototype.$ajax = axios</span><br></pre></td></tr></table></figure>
<h4 id="应用：一个简单的登录接口"><a href="#应用：一个简单的登录接口" class="headerlink" title="应用：一个简单的登录接口"></a>应用：一个简单的登录接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.$ajax(&#123;</span><br><span class="line">　　method: &apos;post&apos;,</span><br><span class="line">　　url: &apos;/login&apos;,</span><br><span class="line">　　data: &#123;</span><br><span class="line">　　　　&apos;userName&apos;: &apos;haha&apos;,</span><br><span class="line">　　　　&apos;password&apos;: &apos;123456&apos;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">　　console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>eg: axios拦截器对路由进行拦截</p>
<h4 id="1-路由拦截"><a href="#1-路由拦截" class="headerlink" title="1.路由拦截"></a>1.路由拦截</h4><p>在定义路由的时候就需要多添加一个自定义字段requireAuth，用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由，否则就进入登录页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: &apos;/&apos;,</span><br><span class="line">        name: &apos;/&apos;,</span><br><span class="line">        component: Index</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &apos;/repository&apos;,</span><br><span class="line">        name: &apos;repository&apos;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            requireAuth: true,  // 添加该字段，表示进入这个路由是需要登录的</span><br><span class="line">        &#125;,</span><br><span class="line">        component: Repository</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &apos;/login&apos;,</span><br><span class="line">        name: &apos;login&apos;,</span><br><span class="line">        component: Login</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>定义完路由后，我们主要是利用vue-router提供的钩子函数beforeEach()对路由进行判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    if (to.meta.requireAuth) &#123;  // 判断该路由是否需要登录权限</span><br><span class="line">        if (token) &#123;  // 判断当前的token是否存在</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            next(&#123;</span><br><span class="line">                path: &apos;/login&apos;,</span><br><span class="line">                query: &#123;redirect: to.fullPath&#125;  // 将跳转的路由path作为参数，登录成功后跳转到该路由</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>to.meta中是我们自定义的数据，其中就包括我们刚刚定义的requireAuth字段<br>通过这个字段来判断该路由是否需要登录权限<br>需要的话，同时当前应用不存在token，则跳转到登录页面，进行登录。登录成功后跳转到目标路由。 </p>
<p>这种方式只是简单的前端路由控制，并不能阻止用户访问，假设有一种情况：当前token失效了，但是token依然保存在本地。这时候你去访问需要登录权限的路由时，实际上应该让用户重新登录。这时候就需要结合 http 拦截器 + 后端接口返回的http 状态码来判断。</p>
<h4 id="2-拦截器"><a href="#2-拦截器" class="headerlink" title="2.拦截器"></a>2.拦截器</h4><p>要想统一处理所有http请求和响应，就得用上 axios 的拦截器。通过配置http response inteceptor，当后端接口返回401 Unauthorized（未授权），让用户重新登录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// http request 拦截器</span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        if (stoken) &#123;  // 判断是否存在token，如果存在的话，则每个http header都加上token</span><br><span class="line">            config.headers.Authorization = `token $&#123;store.state.token&#125;`;</span><br><span class="line">        &#125;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        return Promise.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">// http response 拦截器</span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        if (error.response) &#123;</span><br><span class="line">            switch (error.response.status) &#123;</span><br><span class="line">                case 401:</span><br><span class="line">                    // 返回 401 清除token信息并跳转到登录页面</span><br><span class="line">                    </span><br><span class="line">                    router.replace(&#123;</span><br><span class="line">                        path: &apos;login&apos;,</span><br><span class="line">                        query: &#123;redirect: router.currentRoute.fullPath&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error.response.data)   // 返回接口返回的错误信息</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/08/27/es6 class深入了解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/es6 class深入了解/" itemprop="url">es6中class的深入了解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-27T21:43:51+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/27/es6 class深入了解/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/08/27/es6 class深入了解/" class="cy_cmt_count" data-xid="2018/08/27/es6 class深入了解/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>相信es6中的class（类）对我们来说并不陌生，在我的工作中，也用到了ES6这一特性，虽然一直在使用，但是并没有去认真了解过它，于是做了一些功课，在这里跟大家分享自己的一些心得和看法。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>在ES6以前，JS并没有给我们提供对类的支持，常用做法是用构造函数来模拟类的实现，通过将属性和方法定义在原型上将自身的属性共享给它的实例。<br>来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = function () &#123;</span><br><span class="line">  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let p = new Point(1, 2);</span><br><span class="line">p.toString()</span><br></pre></td></tr></table></figure></p>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念。通过class关键字，可以定义类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return `( $&#123;this.x&#125;, $&#123;this.y&#125; )`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Point(1,2) </span><br><span class="line">p.toString()</span><br><span class="line">//(1,2)</span><br></pre></td></tr></table></figure></p>
<p>解释：<br>constructor：构造方法，<br>this: 表示实例对象，<br>toString： 实例的方法  </p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor是类的默认方法，通过new 命令生成对象实例时，自动调用该方法，一个类必须有constructor方法，如果没有显示定义，会默认添加一个空的constructor方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123; &#125; //等同于</span><br><span class="line">class Point &#123; </span><br><span class="line">    constructor () &#123; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>constructor方法默认返回实例对象（this）,如果我们指定返回另一个对象  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123; </span><br><span class="line">    constructor () &#123; </span><br><span class="line">        return Object.create(null); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">let p = new Person() </span><br><span class="line">p instanceof Person //false </span><br><span class="line">// 实例 instanceof 构造函数 用来判断实例是否是构造函数的实例</span><br></pre></td></tr></table></figure>
<p>ES6 的(class)类，完全可以看作构造函数的另一种写法, 类的数据类型就是函数，类本身就指向构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof Point // &quot;function&quot;</span><br><span class="line">Point === Point.prototype.constructor // true</span><br></pre></td></tr></table></figure>
<p>类必须使用new调用，否则会报错。<br>在定义类的时候，前面不需要加function关键字 </p>
<h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>如果类的方法内部含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  printName(name = &apos;there&apos;) &#123;</span><br><span class="line">    this.print(`Hello $&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = new Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName(); // TypeError: Cannot read property &apos;print&apos; of undefined</span><br></pre></td></tr></table></figure></p>
<h3 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h3><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return `( $&#123;this.x&#125;, $&#123;this.y&#125; )`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let point = new Point(2, 3);</span><br><span class="line"></span><br><span class="line">point.toString() // (2, 3)</span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(&apos;x&apos;) </span><br><span class="line">point.hasOwnProperty(&apos;y&apos;) </span><br><span class="line">point.hasOwnProperty(&apos;toString&apos;) </span><br><span class="line">point.__proto__.hasOwnProperty(&apos;toString&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h3><p>所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123; </span><br><span class="line">    static classMethod() &#123; </span><br><span class="line">        return &apos;hello&apos;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">Foo.classMethod() // &apos;hello&apos; </span><br><span class="line">let foo = new Foo(); </span><br><span class="line">foo.classMethod() // TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure></p>
<p>思考一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static bar () &#123;</span><br><span class="line">    this.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  static baz () &#123;</span><br><span class="line">    console.log(&apos;hello&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  baz () &#123;</span><br><span class="line">    console.log(&apos;world&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() // ??</span><br></pre></td></tr></table></figure></p>
<p>如果静态方法包含this关键字，这个this指的是类，而不是实例, 从这个例子还可以看出，静态方法可以与非静态方法重名。<br>所以这个例子最终打印出来的会是 hello.</p>
<h3 id="Class-的静态属性和实例属性"><a href="#Class-的静态属性和实例属性" class="headerlink" title="Class 的静态属性和实例属性"></a>Class 的静态属性和实例属性</h3><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>静态属性和静态方法都是一样，都是定义在类上，而不是实例对象上。<br>先来感受一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static prop = 1;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prop // 1</span><br></pre></td></tr></table></figure></p>
<h4 id="类的实例属性"><a href="#类的实例属性" class="headerlink" title="类的实例属性"></a>类的实例属性</h4><p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    myProp = 42;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">      console.log(this.myProp); // 42</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以前我们定义实例属性，只能写在constructor方法里面，像下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Index extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  static hello() &#123;</span><br><span class="line">    console.log(&apos;hello world&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    this.color = color; // ReferenceError</span><br><span class="line">    super(x, y);  // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color; // 正确</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。<br>父类的静态方法，也会被子类继承</p>
<h3 id="类的私有属性和私有方法"><a href="#类的私有属性和私有方法" class="headerlink" title="类的私有属性和私有方法"></a>类的私有属性和私有方法</h3><h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><p>ES6 不支持私有属性。目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示<br>之所以要引入一个新的前缀#表示私有属性，是因为js没有private关键字<br>另外，Ruby 语言使用@表示私有属性，ES6 没有用@符号而使用#，是因为@已经被留给了 Decorator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  #x;</span><br><span class="line">  constructor(x = 0) &#123;</span><br><span class="line">  #x = +x; // 写成 this.#x 亦可</span><br><span class="line">  &#125;</span><br><span class="line">  get x() &#123; return #x &#125;</span><br><span class="line">  set x(value) &#123; #x = +value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>私有方法是常见需求，但 ES6 不提供，只能通过其他方法模拟实现<br>第一种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">  // 公有方法</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">  this._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line">  // 私有方法</span><br><span class="line">  _bar(baz) &#123;</span><br><span class="line">  return this.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法<br>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const bar = Symbol(&apos;bar&apos;);</span><br><span class="line">const snaf = Symbol(&apos;snaf&apos;);</span><br><span class="line">export default class myClass&#123;</span><br><span class="line">  // 公有方法</span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    this[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line">  // 私有方法</span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    return this[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/08/05/web图片加载与渲染/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/05/web图片加载与渲染/" itemprop="url">web图片加载与渲染时机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-05T23:44:15+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/08/05/web图片加载与渲染/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/08/05/web图片加载与渲染/" class="cy_cmt_count" data-xid="2018/08/05/web图片加载与渲染/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>管理好网页的图片资源,可以避免不必要的流量和提高用户体验。</p>
<h3 id="浏览器的工作流程"><a href="#浏览器的工作流程" class="headerlink" title="浏览器的工作流程"></a>浏览器的工作流程</h3><p>要研究图片资源的加载，就不得不先熟悉浏览器的工作原理，下面这张图可以很清晰的说明<br><img src="https://user-images.githubusercontent.com/9698086/26868233-de8d0f06-4b9a-11e7-8b35-0c6bfbe9871b.png" alt="image"></p>
<p>从上图可看出，浏览器加载一个HTML页面后进行如下操作(详细解释图片资源渲染)：  </p>
<ul>
<li>解析HTML(遇到img标签加载图片) —&gt; 构建DOM树</li>
<li>加载css —&gt; 解析css（遇到背景图片链接不加载） —&gt; 构建css树</li>
<li>加载js代码 —&gt; 执行js代码</li>
<li>把DOM树和css树匹配构建渲染树（遍历DOM树时加载对应样式规则上的背景图片）</li>
<li>计算元素位置进行布局</li>
<li>绘制（开始渲染图片）</li>
</ul>
<h3 id="图片加载与渲染规则"><a href="#图片加载与渲染规则" class="headerlink" title="图片加载与渲染规则"></a>图片加载与渲染规则</h3><p>了解了浏览器的工作流程，现在来说说图片的加载和渲染，并不是所有的img标签图片和样式表背景图片都会加载  </p>
<h4 id="重复图片"><a href="#重复图片" class="headerlink" title="重复图片"></a>重复图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.img-bg &#123;</span><br><span class="line">    background: url(./demo.png);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;img-bg&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;img src=&quot;./demo.png&quot;&gt;</span><br><span class="line">&lt;img src=&quot;./demo.png&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>页面中多个img标签或样式表中的背景图片图片路径是同一个，图片只加载一次。<br>原因：浏览器请求资源时，都会先判断是否有缓存，若有缓存且未过期则会从缓存中读取，不会再次请求。先加载的图片会存储到浏览器缓存中，后面再次请求同路径图片时会直接读取缓存中的图片。</p>
<h4 id="设置display-none的图片"><a href="#设置display-none的图片" class="headerlink" title="设置display: none的图片"></a>设置display: none的图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;./demo1.png&quot; style=&quot;display: none;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>设置了display:none属性的元素，图片不会渲染出来，但会加载。<br>原因：在解析HTML时，遇到img标签就加载图片，DOM树和样式规则树匹配构建渲染树时，只会把可见元素和它对应的样式规则结合一起产出到渲染树  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.img &#123;</span><br><span class="line">    background: url(./demo.png);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div style=&quot;display:none&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./demo1.png&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;img&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>如果父元素设置了display:none属性，那么子元素样式表中的背景图片不会渲染出来，也不会加载；而img标签的图片不会渲染出来，但会加载。<br>原因：在解析HTML时，遇到img标签就加载图片，当构建渲染树遇到了设置了display:none属性的不可见元素时，不会继续遍历不可见元素的子元素，因此不会加载该元素中子元素的背景图片</p>
<h4 id="伪类的背景图片"><a href="#伪类的背景图片" class="headerlink" title="伪类的背景图片"></a>伪类的背景图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.img &#123;</span><br><span class="line">    background: url(./domo.png);</span><br><span class="line">&#125;</span><br><span class="line">.img:hover&#123;</span><br><span class="line">    background: url(./demo1.png);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;img&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>当触发伪类的时候，伪类样式上的背景图片才会加载。<br>原因：触发hover前，构建渲染树过程中，遍历DOM树时，该元素匹配的样式规则是无hover状态选择器.img的样式；触发hover后，因为.img:hover的优先级比较高，构建新的渲染树过程中，会加载伪类的背景图片。</p>
<h4 id="不存在元素的背景图片"><a href="#不存在元素的背景图片" class="headerlink" title="不存在元素的背景图片"></a>不存在元素的背景图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.img111 &#123;</span><br><span class="line">    background: url(./domo.png);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;img&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>不存在元素的背景图片不会加载。<br>原因：不存在的元素不会产出到DOM树上，构建渲染树过程中遍历DOM树时无法遍历不存在的元素，因此不会加载图片，也不会产出到渲染树上。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="占位图"><a href="#占位图" class="headerlink" title="占位图"></a>占位图</h4><p>当使用样式表中的背景图片作为占位符时，要把背景图片转为base64格式。这是因为背景图片加载的顺序在img标签后面，背景图片可能会在img标签图片加载完成后才开始加载，达不到想要的效果。</p>
<h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><ul>
<li>使用上文讲到的，设置了display:none属性的元素，图片不会渲染出来，但会加载。把要预加载的图片加到设置了display:none的元素背景图或img标签里。</li>
<li>在javascript创建img对象，把图片url设置到img对象的src属性里。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/06/21/js排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/js排序算法/" itemprop="url">js排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-21T23:25:09+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/06/21/js排序算法/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/06/21/js排序算法/" class="cy_cmt_count" data-xid="2018/06/21/js排序算法/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>依次比较相邻的两个值，如果后面的比前面的小，则将小的元素排到前面。依照这个规则进行多次并且递减的迭代，直到顺序正确。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var examplearr=[4,24,15,37,55,71,28,30];</span><br><span class="line">function sort(arr)&#123;</span><br><span class="line">    for(i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">            if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                var temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+1];</span><br><span class="line">                arr[j+1]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">sort(examplearr);</span><br><span class="line">console.log(examplearr);</span><br></pre></td></tr></table></figure></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>使用两个循环</p>
<p>当i=0的时候，执行内层循环，从j=0执行到j=6,这也就是第一遍排序，结果是将最大的数排到了最后。<br>当i=1的时候，再次执行内层循环，由于最大的数已经在最后了，没有必要去比较数组的最后两项，这也是为什么要用j&lt;arr.length-1-i</p>
<p>按照这个规律，每次将剩下数组里面最大的一个数排到最后面，当执行到i=6时，就只需要比较第一项和第二项，交换之后就排序结束。</p>
<p>算法分析</p>
<p>最佳情况：T(n) = O(n)<br>最差情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)</p>
<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>选择排序算法是一种原址比较算法。选择排序的大致思路是找到数据结构中的最小值，并将其放置在第一位，接着找到第二小的值放到第二位，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function selectSort(arr)&#123;</span><br><span class="line">    var len=arr.length;</span><br><span class="line">    var temp;</span><br><span class="line">    for(var i=0;i&lt;len-1;i++)&#123;</span><br><span class="line">        for(var j=i+1;j&lt;len;j++)&#123;</span><br><span class="line">            if(arr[j]&lt;arr[i])&#123;</span><br><span class="line">                temp=arr[j];</span><br><span class="line">                arr[j]=arr[i];</span><br><span class="line">                arr[i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>把每一个数都与第一个数比较，如果小于第一个数，就把它们交换位置；这样一轮下来，最小的数就排到了最前面；重复n-1轮，就实现了选择排序</p>
<p>选择排序和冒泡排序思想上有些相近</p>
<p>算法分析</p>
<p>最佳情况：T(n) = O(n2)<br>最差情况：T(n) = O(n2)<br>平均情况：T(n) = O(n2)</p>
<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><p>插入排序每次排一个数组项，以此方式构建最后的排序数组，假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样头两项就已经正确排序，接着和第三项比较（它是该插入第一、第二还是第三的位置呢？）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">this.insertionSort = function()&#123;</span><br><span class="line">    var length = array.length,</span><br><span class="line">        j, temp;</span><br><span class="line">    for (var i=1; i&lt;length; i++)&#123;</span><br><span class="line">        j = i;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        while (j&gt;0 &amp;&amp; array[j-1] &gt; temp&#123;</span><br><span class="line">            array[j] = array[j-1];</span><br><span class="line">            j--; </span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="排序过程大概如下："><a href="#排序过程大概如下：" class="headerlink" title="排序过程大概如下："></a>排序过程大概如下：</h4><p>从第一个元素开始，该元素可以认为已经被排序；<br>取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；<br>重复步骤2~5。 </p>
<p>算法分析 </p>
<p>最佳情况：输入数组按升序排列。T(n) = O(n)<br>最坏情况：输入数组按降序排列。T(n) = O(n2)<br>平均情况：T(n) = O(n2)</p>
<p>未完待续。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/05/21/Vue组件之间通信方式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/21/Vue组件之间通信方式总结/" itemprop="url">vue 组件的通信方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-21T22:00:25+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/05/21/Vue组件之间通信方式总结/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/05/21/Vue组件之间通信方式总结/" class="cy_cmt_count" data-xid="2018/05/21/Vue组件之间通信方式总结/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在使用Vue开发的时候，组件之间的通信很常用，每次在需要用到的时候，都要去查文档，所以干脆整理一下，免得总是忘记。</p>
<h3 id="父组件向子组件传递数据"><a href="#父组件向子组件传递数据" class="headerlink" title="父组件向子组件传递数据"></a>父组件向子组件传递数据</h3><p>1.props：这个是最简单的一种通信了，通过props就可以向子组件传递数据了  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**父组件代码**/</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Child :title-txt=&quot;showTitleTxt&quot;&gt;&lt;/Child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import Child from &apos;./child&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &apos;index&apos;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            Child</span><br><span class="line">        &#125;,</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                showTitleTxt: &apos;这是父组件&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**子组件代码**/</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &#123;&#123;titleTxt&#125;&#125;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &apos;header-box&apos;,</span><br><span class="line">        props: [&apos;titleTxt&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2.使用$children可以在父组件中访问子组件。</p>
<h3 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h3><p>子组件向父组件传递数据，可以有两种方式<br>1.props：通过props中的Object类型参数传输数据，可以通过子组件改变父组件的数据内容。这种方式是可行的，但是官方不推荐使用，因为官方定义prop是单向绑定<br>2.通过$on和$emit  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**父组件代码**/</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Child @addFun=&quot;add&quot;&gt;&lt;/Child&gt;</span><br><span class="line">    &#123;&#123; total &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">import Child from &apos;./child.vue&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        Child</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            total: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add (counter) &#123;</span><br><span class="line">            this.total = this.total + counter</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**子组件代码**/</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;加&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods () &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                counter: 10</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            this.$emit(addFun, this.counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h3><h4 id="中央事件总线"><a href="#中央事件总线" class="headerlink" title="中央事件总线"></a>中央事件总线</h4><p>简单情况下我们可以通过使用一个空的Vue实例作为中央事件总线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**bus.js**/</span><br><span class="line">let bus = new Vue()</span><br><span class="line">Vue.prototype.bus = bus</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**header组件**/</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;header @click=&quot;changeTitle&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/header&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &apos;header&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            title: &apos;头部&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeTitle () &#123;</span><br><span class="line">            this.bus.$emit(&apos;toChangeTitle&apos;,&apos;首页&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**footer组件**/</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;footer&gt;&#123;&#123;txt&#125;&#125;&lt;/footer&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &apos;footer&apos;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">        this.bus.$on(&apos;toChangeTitle&apos;, (title) =&gt; &#123;</span><br><span class="line">            console.log(title)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            txt: &apos;尾部&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><p>如果项目结构复杂化以后，这样的自定义事件变多以后代码难以管理，所以还是建议使用vuex。<br>虽然暂时还没有用上vuex，不见得以后用不上，可以先学习下<br>如果已经了解过redux或者flux，那么vuex也是类似的，官方的说法就是Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。<br>vuex有四个核心概念，其中state和getters主要是用于数据的存储与输出，而mutations和actions是用于提交事件并修改state中的数据。<br><img src="https://raw.githubusercontent.com/vuejs/vuex/dev/docs/en/images/vuex.png" alt="image"></p>
<p>参考官方的目录结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── dialog_store.js       # 消息提示模块</span><br></pre></td></tr></table></figure></p>
<h5 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**index.js**/</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import vuex from &apos;vuex&apos;</span><br><span class="line">Vue.use(vuex);</span><br><span class="line"></span><br><span class="line">import dialog_store from &apos;../components/dialog_store.js&apos;;//引入某个store对象</span><br><span class="line"></span><br><span class="line">export default new vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        dialog: dialog_store</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**dialog_store.js**/</span><br><span class="line">export default &#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        show:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**在主入口文件中**/</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,//使用store</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    state:&#123;//state</span><br><span class="line">        show:false</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        switch_dialog(state)&#123;//这里的state对应着上面这个state</span><br><span class="line">            state.show = state.show ? false : true;</span><br><span class="line">            //你还可以在这里执行其他的操作改变state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> export default &#123;</span><br><span class="line">    state:&#123;//state</span><br><span class="line">        show:false</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        switch_dialog(state)&#123;//这里的state对应着上面这个state</span><br><span class="line">            state.show = state.show?false:true;</span><br><span class="line">            //你还可以在这里执行其他的操作改变state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">        switch_dialog(context)&#123;//这里的context和我们使用的$store拥有相同的对象和方法</span><br><span class="line">            context.commit(&apos;switch_dialog&apos;);</span><br><span class="line">            //你还可以在这里触发其他的mutations方法</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于vuex,我也了解的不是很多，在具体组件中的使用，可以参考官网的<a href="https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart" target="_blank" rel="noopener">购物车</a>例子</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/04/22/async 函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/async 函数/" itemprop="url">Async 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T21:32:38+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/04/22/async 函数/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/04/22/async 函数/" class="cy_cmt_count" data-xid="2018/04/22/async 函数/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着 Node 7 的发布，越来越多的人开始研究据说是异步编程终级解决方案的 async/await，在我们的很多项目中都已经开始使用async函数，下面就来一起理解下Javascript处理异步的async函数。</p>
<h3 id="初识async-await"><a href="#初识async-await" class="headerlink" title="初识async/await"></a>初识async/await</h3><p>Async/await 是Javascript编写异步程序的新方法。以往的异步方法无外乎回调函数和Promise。但是Async/await建立于Promise之上，async 函数算是一个语法糖，使异步函数、回调函数在语法上看上去更像同步函数，很多人认为它是异步操作的终极解决方案。</p>
<h3 id="async-await语法"><a href="#async-await语法" class="headerlink" title="async/await语法"></a>async/await语法</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function test () &#123;</span><br><span class="line">    return &apos;hello async&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result = test();</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">// 可以看到，控制台输出了一个Promise对象</span><br><span class="line">// Promise &#123; &apos;hello async&apos; &#125;</span><br><span class="line"></span><br><span class="line">// 可以then() 链来处理这个 Promise 对象</span><br><span class="line">test().then(v =&gt; &#123;</span><br><span class="line">    console.log(v);    // 输出 hello async</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数一样。所以这个await函数就至关重要了。</p>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function testAwait() &#123;</span><br><span class="line">  return await 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testAwait().then(v =&gt; console.log(v))</span><br><span class="line">// 123</span><br></pre></td></tr></table></figure>
<p>只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function testAwait() &#123;</span><br><span class="line">  await Promise.reject(&apos;出错了&apos;);</span><br><span class="line">  await Promise.resolve(&apos;hello&apos;); // 不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以当一个 async 函数中有多个 await命令时，如果不想因为一个出错而导致其与的都无法执行，应将await放在try…catch语句中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function testAwait &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(&apos;出错了&apos;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  return await Promise.resolve(&apos;hello world&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testAwait()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function testAwait() &#123;</span><br><span class="line">  await Promise.reject(&apos;出错了&apos;)</span><br><span class="line">    .catch(e =&gt; console.log(e));</span><br><span class="line">  return await Promise.resolve(&apos;hello world&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testAwait()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">// 出错了</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure></p>
<h3 id="并发执行-await-命令"><a href="#并发执行-await-命令" class="headerlink" title="并发执行 await 命令"></a>并发执行 await 命令</h3><p>当一个 async 函数中有多个await时，这些 await是继发执行的，只有当前一个await后面的方法执行完毕后，才会执行下一个。<br>如果我们前后的方法由依赖关系，继发执行是没有问题的，但是如果并没有任何关系的话，这样就会很耗时，所以需要让这些await命令同时执行，也就是并发执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 方法 1 使用Promise.all</span><br><span class="line">let results = await Promise.all([func1(), func2()])</span><br><span class="line"></span><br><span class="line">// 方法 2</span><br><span class="line">let func1Promise = func1()</span><br><span class="line">let func2Promise = func2()</span><br><span class="line">let res1 = await func1Promise</span><br><span class="line">let res2 = await func2Promise</span><br></pre></td></tr></table></figure>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。<br>防止出错的方法，也是将其放在try…catch代码块之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function errtest() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await new Promise(function (resolve, reject) &#123;</span><br><span class="line">      throw new Error(&apos;出错了&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  return await(&apos;hello world&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果有多个await命令，可以统一放在try…catch结构中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function errtest() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const val1 = await firstStep();</span><br><span class="line">    const val2 = await secondStep(val1);</span><br><span class="line">    const val3 = await thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    console.log(&apos;Final: &apos;, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (err) &#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。  </li>
<li>使用async关键字声明异步函数。</li>
<li>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。  </li>
<li>async用来申明里面包裹的内容可以进行同步的方式执行，await则是进行执行顺序控制，每次执行一个await，程序都会暂停等待await返回值，然后再执行之后的await。</li>
<li>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li>
</ol>
<h3 id="async-await-的优势"><a href="#async-await-的优势" class="headerlink" title="async/await 的优势"></a>async/await 的优势</h3><h4 id="then-链"><a href="#then-链" class="headerlink" title="then 链"></a>then 链</h4><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p>
<h4 id="中间值"><a href="#中间值" class="headerlink" title="中间值"></a>中间值</h4><p>一个经常出现的场景是，我们先调起promise1，然后根据返回值，调用promise2，之后再根据这两个Promises得值，调取promise3。<br>对比一下Promise和async/await的实现方式，就可以发现 async/await代码非常简单，结构清晰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Promise</span><br><span class="line">const makeRequest = () =&gt; &#123;</span><br><span class="line">    return promise1()</span><br><span class="line">        .then(value1 =&gt; &#123;</span><br><span class="line">            // do something</span><br><span class="line">            return promise2(value1)</span><br><span class="line">                .then(value2 =&gt; &#123;</span><br><span class="line">                    // do something          </span><br><span class="line">                    return promise3(value1, value2)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// async/await</span><br><span class="line">const makeRequest = async () =&gt; &#123;</span><br><span class="line">    const value1 = await promise1()</span><br><span class="line">    const value2 = await promise2(value1)</span><br><span class="line">    return promise3(value1, value2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有很多的优点，就看大家实际项目中去挖掘了。<br>thank you</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/03/20/Css Grid Layout(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/Css Grid Layout(一)/" itemprop="url">CSS Grid Layout (一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-20T21:34:50+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/03/20/Css Grid Layout(一)/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/03/20/Css Grid Layout(一)/" class="cy_cmt_count" data-xid="2018/03/20/Css Grid Layout(一)/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在介绍Grid之前，先来说一下flex吧，引用阮大神的一句话：2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。在这几年，flex布局已然成为前端的主流布局框架，每一个前端开发者都必须要掌握flexbox的用法。<br>然而，在2017年，Grid来势汹汹，声势浩大，相信大家就算没有在项目中使用过，也一定听过这个。Grid最大的特色，就是采用了二维布局，之前的布局方式都是采用一维布局。目前Grid的规范也逐渐完善，flex和grid各有千秋，日后这个后起之秀会不会成为web布局的扛把子，谁也说不准。</p>
<p>下面，就来介绍下本文的主角 <font color="#A52A2A">Grid</font></p>
<h3 id="简介已经支持情况"><a href="#简介已经支持情况" class="headerlink" title="简介已经支持情况"></a>简介已经支持情况</h3><h4 id="Grid简介"><a href="#Grid简介" class="headerlink" title="Grid简介"></a>Grid简介</h4><p>Grid：CSS网格布局（又名“网格”）是一个二维的基于网格的布局系统，其目的只在于完全改变我们设计基于网格的用户界面的方式。CSS一直用来布局网页，但一直都不完美。 一开始我们使用table 做布局，然后转向浮动、定位以及inline-block，但所有这些方法本质上都是 Hack 的方式，并且遗漏了很多重要的功能（例如垂直居中）。 Flexbox的出现在一定程度上解决了这个问题，但是它的目的是为了更简单的一维布局，而不是复杂的二维布局（Flexbox和Grid实际上一起工作得很好）。 只要我们一直在制作网站，我们就一直在为解决布局问题不断探索， 而Grid是第一个专门为解决布局问题而生的CSS模块。</p>
<h4 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h4><p><img src="/images/llq.jpg" alt="浏览器支持情况ß"></p>
<h3 id="Gird的基本概念"><a href="#Gird的基本概念" class="headerlink" title="Gird的基本概念"></a>Gird的基本概念</h3><h4 id="1-网格容器（Grid-Container），对应Flexbox布局中的Flex容器"><a href="#1-网格容器（Grid-Container），对应Flexbox布局中的Flex容器" class="headerlink" title="1.网格容器（Grid Container），对应Flexbox布局中的Flex容器"></a>1.网格容器（Grid Container），对应Flexbox布局中的Flex容器</h4><p>元素应用display:grid，它是其所有网格项的父元素。下面例子container就是网格容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item item-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt; </span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-网格项（Grid-Item）-对应Flexbox布局中的Flex项目"><a href="#2-网格项（Grid-Item）-对应Flexbox布局中的Flex项目" class="headerlink" title="2.网格项（Grid Item）, 对应Flexbox布局中的Flex项目"></a>2.网格项（Grid Item）, 对应Flexbox布局中的Flex项目</h4><p>网格容器的子元素，下面的item元素是网格项，但sub-item不是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; </span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">        &lt;p class=&quot;sub-item&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-网格线-Grid-lines"><a href="#3-网格线-Grid-lines" class="headerlink" title="3.网格线(Grid lines)"></a>3.网格线(Grid lines)</h4><p>网格线是用来在水平和垂直方向分割网格的线。水平方向的网格线是从左向右；垂直方向是从上往下。网格线的编号都是从1开始的。</p>
<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2016/1609/example-grid-lines.svg" alt="网格线"></p>
<h4 id="4-网格轨道（Grid-Track）"><a href="#4-网格轨道（Grid-Track）" class="headerlink" title="4.网格轨道（Grid Track）"></a>4.网格轨道（Grid Track）</h4><p>两个相邻的网格线之间为网格轨道。你可以认为它们是网格的列或行。</p>
<h4 id="5-网格单元（Grid-Cell）"><a href="#5-网格单元（Grid-Cell）" class="headerlink" title="5.网格单元（Grid Cell）"></a>5.网格单元（Grid Cell）</h4><p>两个相邻的列网格线和两个相邻的行网格线组成的是网格单元，它是最小的网格单元。</p>
<h4 id="6-网格区（Grid-Area）"><a href="#6-网格区（Grid-Area）" class="headerlink" title="6.网格区（Grid Area）"></a>6.网格区（Grid Area）</h4><p>网格区是由任意数量网格单元组成。</p>
<h3 id="父容器-Grid-Container-的属性"><a href="#父容器-Grid-Container-的属性" class="headerlink" title="父容器(Grid Container)的属性"></a>父容器(Grid Container)的属性</h3><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>将元素定义为 grid contaienr，并为其内容建立新的网格格式化上下文(grid formatting context)。<br>属性值：  </p>
<ul>
<li>grid: 生成块级网格</li>
<li>inline-grid: 生成行内网格</li>
<li>subgrid: 如果网格容器本身是网格项grid item（嵌套网格容器），此属性用来继承其父网格容器的列、行大小。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: grid | inline-grid | subgrid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：column, float, clear, 以及 vertical-align 对一个 grid container 没有影响</p>
<h4 id="grid-template-columns-grid-template-rows-网格列和网格行"><a href="#grid-template-columns-grid-template-rows-网格列和网格行" class="headerlink" title="grid-template-columns / grid-template-rows (网格列和网格行)"></a>grid-template-columns / grid-template-rows (网格列和网格行)</h4><p>使用以空格分隔的多个值来定义网格的列和行。这些值表示轨道大小，它们之间的空格代表表格线。当你设置行或列大小为auto时，网格会自动分配空间和网格线名称<br>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 基本用法</span><br><span class="line">.container &#123;</span><br><span class="line">    grid-template-columns: 40px 50px auto 50px 40px;</span><br><span class="line">    grid-template-rows: 25% 100px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以给每条网格线命名</span><br><span class="line">.container &#123;</span><br><span class="line">    grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];</span><br><span class="line">    grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> // 每条网格线也可以不止一个名字</span><br><span class="line">.container &#123;</span><br><span class="line">    grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];</span><br><span class="line">    grid-template-rows: [row1-start] 25% [row1-end row2-start] 100px [third-line] auto [last-line];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果有重复的部分，可以使用repeat函数</span><br><span class="line">.container &#123;</span><br><span class="line">    grid-template-columns: repeat(3, 30px [col]) 40px;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line">.container &#123;</span><br><span class="line">    30px [col] 30px [col] 30px [col] 40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cloud.hunger-valley.com/18-1-18/39647772.jpg" alt=""></p>
<p>可以使用fr单位可以将容器分为几等份，如果和实际值一起用，则代表分割剩余的部分，例如下面分成三等份</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    display:grid;</span><br><span class="line">    grid-template-columns: 1fr 1fr 1fr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container&#123;</span><br><span class="line">    display:grid;</span><br><span class="line">    grid-template-columns: 1fr 100px 1fr 1fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网格项的属性"><a href="#网格项的属性" class="headerlink" title="网格项的属性"></a>网格项的属性</h3><h4 id="网格项属性"><a href="#网格项属性" class="headerlink" title="网格项属性"></a>网格项属性</h4><ul>
<li>grid-column-start：设置网格项目垂直方向的开始位置网格线</li>
<li>grid-column-end：设置网格项目垂直方向的结束位置网格线</li>
<li>grid-row-start：设置网格项目水平方向的开始位置网格线</li>
<li>grid-row-end：设置网格项目水平方向的结束位置网格线</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;section class=&quot;grid-1&quot;&gt;  </span><br><span class="line">    &lt;div class=&quot;item-1&quot;&gt;1&lt;/div&gt;  </span><br><span class="line">    &lt;div class=&quot;item-2&quot;&gt;2&lt;/div&gt;  </span><br><span class="line">    &lt;div class=&quot;item-3&quot;&gt;3&lt;/div&gt;  </span><br><span class="line">    &lt;div class=&quot;item-4&quot;&gt;4&lt;/div&gt;  </span><br><span class="line">    &lt;div class=&quot;item-5&quot;&gt;5&lt;/div&gt;  </span><br><span class="line">    &lt;div class=&quot;item-6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">.grid-1 &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    width: 100%;</span><br><span class="line">    max-width: 600px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    grid-template-columns: 300px 200px 100px;</span><br><span class="line">    grid-template-rows: 100px 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item-2 &#123;</span><br><span class="line">  grid-column-start: 2;</span><br><span class="line">  grid-column-end: 4;</span><br><span class="line">  grid-row-start: 1;</span><br><span class="line">  grid-row-end: 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 两个属性缩写</span><br><span class="line">item-2 &#123;</span><br><span class="line">    grid-column: 2 / 4;</span><br><span class="line">    grid-row: 1 / 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 四个属性缩写</span><br><span class="line">grid-row-start / grid-column-start/ grid-row-end / grid-column-end</span><br><span class="line">item-2 &#123;</span><br><span class="line">    grid-area: 1 / 2 / 2 / 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/Grid.jpg" alt="&#39;结果&#39;"></p>
<h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h4><p>其实上面的例子中已经实现了两个单元格合并（第二列和第三列），其实在Grid布局中提供了一个<font color="#A52A2A">span关键词</font>来实现单元格的跨越，span 后面跟的数字表示跨越多少个单元格。类似于table中的合并单元格，比如colspan合并列，rowspan合并行。</p>
<p>注意：如果没有设置grid-column-end或grid-row-end，默认将跨越一个轨道。项目也可以重叠，设置z-index来确定堆叠顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 等价与上面的合并第二列和第三列</span><br><span class="line">.item-2 &#123; </span><br><span class="line">    grid-column: 2 / span 2; </span><br><span class="line">    grid-row: 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">.item-2 &#123; </span><br><span class="line">    grid-area: 2 / 1 / span 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单个网格项垂直于列网格线的对齐方式"><a href="#单个网格项垂直于列网格线的对齐方式" class="headerlink" title="单个网格项垂直于列网格线的对齐方式"></a>单个网格项垂直于列网格线的对齐方式</h4><p>属性值：</p>
<ul>
<li>start: 网格区域左对齐。</li>
<li>end: 网格区域右对齐。</li>
<li>center: 网格区域居中。</li>
<li>stretch: 网格区域填满。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item-1&#123;</span><br><span class="line">    justify-self: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以给父容器设置justify-items，达到全部网格项对齐</p>
<h4 id="单个网格项垂直于列网格线的对齐方式-1"><a href="#单个网格项垂直于列网格线的对齐方式-1" class="headerlink" title="单个网格项垂直于列网格线的对齐方式"></a>单个网格项垂直于列网格线的对齐方式</h4><p>属性值：</p>
<ul>
<li>start: 网格区域顶部对齐。</li>
<li>end: 网格区域底部对齐。</li>
<li>center: 网格区域居中。</li>
<li>stretch: 网格区域填满。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item-1&#123;</span><br><span class="line">    align-self: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在容器上设置align-items，达到全部网格项对齐</p>
<p>未完待续…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hupeip.github.io/2018/01/14/Webpack如何编写一个loader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hupei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Web前端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/14/Webpack如何编写一个loader/" itemprop="url">Webpack如何编写一个loader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-14T20:17:43+08:00">
                2018-01-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/01/14/Webpack如何编写一个loader/#SOHUCS" itemprop="discussionUrl">
                  <span id="url::https://hupeip.github.io/2018/01/14/Webpack如何编写一个loader/" class="cy_cmt_count" data-xid="2018/01/14/Webpack如何编写一个loader/" itemprop="commentsCount" ></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！</p>
<p>这种链式调用和gulp跟相似，每一个loader都只关心自己的事，而不是一个loader完成所有的操作。</p>
<h3 id="编写一个-loader"><a href="#编写一个-loader" class="headerlink" title="编写一个 loader"></a>编写一个 loader</h3><h4 id="本地设置"><a href="#本地设置" class="headerlink" title="本地设置"></a>本地设置</h4><ul>
<li><p>匹配(test)单个 loader，你可以简单通过在 rule 对象设置 path.resolve 指向这个本地文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: path.resolve(&apos;path/to/loader.js&apos;),</span><br><span class="line">      options: &#123;/* ... */&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配(test)多个 loaders，你可以使用 resolveLoader.modules 配置，webpack 将会从这些目录中搜索这些 loaders。例如，如果你的项目中有一个 /loaders 本地目录,在loaders下面有很多loader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    &apos;node_modules&apos;,</span><br><span class="line">    path.resolve(__dirname, &apos;loaders&apos;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="loader-工具库"><a href="#loader-工具库" class="headerlink" title="loader 工具库"></a>loader 工具库</h4><p>loader-utils ：它提供了许多有用的工具，最常用的一种工具是获取传递给 loader 的选项。<br>schema-utils ：配合 loader-utils，用于保证 loader 选项，进行与 JSON Schema 结构一致的校验。</p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="编写一个简单的json-loader"><a href="#编写一个简单的json-loader" class="headerlink" title="编写一个简单的json-loader"></a>编写一个简单的json-loader</h4><p>这个loader把简单的Excel表格导出为json对象。提供一个sheet属性，用于选择导出某一页的表格，默认是整个文档。<br>src/loader.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getOptions &#125; from &apos;loader-utils&apos;;</span><br><span class="line">import validateOptions from &apos;schema-utils&apos;;</span><br><span class="line">import xlsx from &apos;.json&apos;;</span><br><span class="line"></span><br><span class="line">// Loader Mode</span><br><span class="line">export const raw = true;</span><br><span class="line"></span><br><span class="line">const schema = &#123;</span><br><span class="line">    type: &quot;object&quot;,</span><br><span class="line">    properties: &#123;</span><br><span class="line">        sheet: &#123;</span><br><span class="line">            anyOf: [</span><br><span class="line">                &#123; type: &quot;number&quot; &#125;,</span><br><span class="line">                &#123; type: &quot;string&quot; &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    additionalProperties: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function loader(source) &#123;</span><br><span class="line">    const options = getOptions(this) || &#123;&#125;;</span><br><span class="line">    validateOptions(schema, options, &apos;xlsx Loader&apos;);</span><br><span class="line"></span><br><span class="line">    source = JSON.stringify(xlsx.toJson(source, options.sheet || null))</span><br><span class="line">        .replace(/\u2028/g, &apos;\\u2028&apos;)</span><br><span class="line">        .replace(/\u2029/g, &apos;\\u2029&apos;)</span><br><span class="line"></span><br><span class="line">    return `export default $&#123; source &#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>raw: loader加载资源的模式，以二进制的方式加载文件，默认值是false，返回源文件内容的字符串。<br>schema：用于校验option选项。<br>xlsx.toJson：用于将源文件转换成json对象。</p>
<h4 id="xlsx源码"><a href="#xlsx源码" class="headerlink" title="xlsx源码"></a>xlsx源码</h4><p><a href="https://github.com/huandhu/xlsx-loader/blob/master/src/json.js" target="_blank" rel="noopener">github地址</a></p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>我们将使用 Jest 框架。然后还需要安装 babel-jest 、 babel-preset-env 和 memory-fs：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jest babel-jest babel-preset-env</span><br></pre></td></tr></table></figure>
<h4 id="使用loader来处理test-example-xlsx文件"><a href="#使用loader来处理test-example-xlsx文件" class="headerlink" title="使用loader来处理test/example.xlsx文件"></a>使用loader来处理test/example.xlsx文件</h4><p>xlsx文件内容</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>biaoge</td>
<td>30</td>
</tr>
<tr>
<td>1</td>
<td>haohua</td>
<td>18</td>
</tr>
</tbody>
</table>
<h4 id="test-compiler-js"><a href="#test-compiler-js" class="headerlink" title="test/compiler.js"></a>test/compiler.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import path from &apos;path&apos;;</span><br><span class="line">import webpack from &apos;webpack&apos;;</span><br><span class="line">import memoryfs from &apos;memory-fs&apos;;</span><br><span class="line"></span><br><span class="line">export default (fixture, options = &#123;&#125;) =&gt; &#123;</span><br><span class="line">    const compiler = webpack(&#123;</span><br><span class="line">        context: __dirname,</span><br><span class="line">        entry: `./$&#123;fixture&#125;`,</span><br><span class="line">        output: &#123;</span><br><span class="line">            path: path.resolve(__dirname),</span><br><span class="line">            filename: &apos;bundle.js&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">        module: &#123;</span><br><span class="line">            rules: [&#123;</span><br><span class="line">                test: /\.xls.?$/,</span><br><span class="line">                loader: path.resolve(__dirname, &apos;../src/index&apos;),</span><br><span class="line">                options</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.outputFileSystem = new memoryfs();</span><br><span class="line"></span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        compiler.run((err, stats) =&gt; &#123;</span><br><span class="line">            if (err) reject(err);</span><br><span class="line"></span><br><span class="line">            resolve(stats);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最后，我们来编写测试，并且添加-npm-script-运行它。"><a href="#最后，我们来编写测试，并且添加-npm-script-运行它。" class="headerlink" title="最后，我们来编写测试，并且添加 npm script 运行它。"></a>最后，我们来编写测试，并且添加 npm script 运行它。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import compiler from &apos;./compiler&apos;;</span><br><span class="line"></span><br><span class="line">test(&apos;getSingle&apos;, async () =&gt; &#123;</span><br><span class="line">  const stats = await compiler(&apos;example.xlsx&apos;, &#123;sheet: &apos;sheet1&apos;&#125;);</span><br><span class="line">  const output = stats.toJson().modules[0].source;</span><br><span class="line">  expect(output).toBe(`export default [&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:&quot;20&quot;&#125;,&#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:&quot;18&quot;&#125;]`);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(&apos;getAll&apos;, async () =&gt; &#123;</span><br><span class="line">  const stats = await compiler(&apos;example.xlsx&apos;);</span><br><span class="line">  const output = stats.toJson().modules[0].source;</span><br><span class="line">  expect(output).toBe(`export default [&#123;&quot;sheet&quot;:&quot;sheet1&quot;,&quot;data&quot;:[&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:&quot;20&quot;&#125;,&#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:&quot;18&quot;&#125;]&#125;, &#123;&quot;sheet&quot;:&quot;sheet2&quot;,&quot;data&quot;:[&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:&quot;20&quot;&#125;,&#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:&quot;18&quot;&#125;]&#125;]`);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="thank-you"><a href="#thank-you" class="headerlink" title="thank you"></a>thank you</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hupei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hupei</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  






  




  
    <script id="cy_cmt_num" src="https://changyan.sohu.com/upload/plugins/plugins.list.count.js?clientId=cytnjt7pL"></script>
  









  





  

  

  

  
  

  

  

  

</body>
</html>
